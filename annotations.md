
### Abstract

> In this work, we introduce a fast implementation of the minimum-weight perfect matching (MWPM) decoder, the most widely used decoder for several important families of quantum error correcting codes, including surface codes.

*Minimum-weight perfect matching* is a graph algorithm that computes the following mapping:

$$ G(V,E) \to E' \subseteq E $$
where `E'` is a perfect matching, such that $$ \sum_{e \in E'} w(e) $$ is minimized. `E'` is a perfect matching if each vertex in `V` is connected to exactly one edge in the set, that is, $$ \forall v\in V, \exists e \in E' \text{ such that } e = (v,v'); e\text{ is unique, and } v\neq v'. [1] $$
A *surface code* is a kind of quantum error correcting code defined on a 2D lattice of qubits. `[2]` A common implementation is alternatively placing X and Z stabilizer circuits. One parameter for a surface code is the code distance `d`, which is the number of errors it can correct, and is the linear dimension of the 2D grid. Surface codes can correct $$ \lfloor(d-1)/2\rfloor $$ errors. `[3]`

> Our algorithm, which we call sparse blossom, is a variant of the blossom algorithm which directly solves the decoding problem relevant to quantum error correction. Sparse blossom avoids the need for all-to-all Dijkstra searches, common amongst MWPM decoder implementations.

The surface code and MWPM algorithm are both essential to solving the decoding problem, which can be formulated in terms of a noise model: any number of the resultant qubits of a quantum computation can be influenced by unwanted noise, and produce an incorrect bit result. These techniques allow us to identify the errant qubits and flip them to the desired output.

An *all-to-all Djikstra search* uses Djikstra's algorithm to find the shortest possible paths between vertices in a graph. `[4]` Djikstra's algorithm has a performance of $$ \Theta(|E| + |V|\log|V|) $$making it asymptotically nonlinear, `[5]` and thus a reasonable candidate for replacement in a large-scale quantum decoder.

> For 0.1% circuit-level depolarising noise, sparse blossom processes syndrome data in both X and Z bases of distance-17 surface code circuits

In the context of quantum computing, depolarizing noise is modeled by a channel that can cause a bit flip (X) or phase flip (Z) with a certain probability. `[6]` These are inevitable in quantum systems due to the extreme sensitivity of quantum particles, such as individual photons, electrons, and ions, to external interference. It can be shown that all qubit errors can be written in terms of bit and phase flips. Quantum computing hardware could be manufactured to empirically guarantee a 0.1% error probability.

>  in less than one microsecond per round of syndrome extraction on a single core, which matches the rate at which syndrome data is generated by superconducting quantum computers.

A syndrome is a piece of classical information that indirectly indicates where an error may have occurred, without exposing information encoded in the qubits. `[7]` Such analysis must be performed with the aid of a classical computer, and this paper offers a solution that can be performed on the order of microseconds with a single classical core.

A superconductor is a material whose electrical resistance vanishes and expels magnetic fields; `[8]` such properties may be exploited to construct quantum computers, though other methods that do not require supercooling are under active research and development.

Putting it all together:

* The surface code the key mathematical representation of an error-correcting circuit. It lays out a 2D array of `d` alternating X and Z stabilizers, and can detect roughly half as many errors. An individual stabilizer has no effect on the quantum circuit, but is a fundamental building block to constructing error-tolerant quantum circuits. They are coupled with classically-enhanced syndrome extraction tools, which indicate the resultant qubits that must be flipped due to errors.
* The MWPM algorithm is used by assigning defects to vertices, and distances between defects on the surface code as weights. The minimum perfect matching represents the most likely error that could have produced an observed syndrome. This matching informs which qubits must be flipped. `[9]`
* MWPM is appropriate for the surface code because of the latter's topological structure, whereby pairs of defects are connected by short paths that MPWM can find. `[9]`
* Current solutions to the syndrome extraction problem rely on Djikstra's algorithm, which may not perform well when used repeatedly at scale. The authors' implementation of the sparse blossom algorithm solves the quantum decoding problem at high performance and low cost.

> Our implementation is open-source, and has been released in version 2 of the PyMatching library.

### Introduction




## Bibliography

[1] Google Gemini definition of MWPM algorithm.<br>
[2] https://quantumcomputing.stackexchange.com/questions/2106/what-is-the-surface-code-in-the-context-of-quantum-error-correction<br>
[3] https://arxiv.org/pdf/2112.03708.pdf<br>
[4] Google Gemini definition of all-to-all Djikstra search<br>
[5] https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm<br>
[6] Google Gemini definition of depolarizing noise in the context of quantum computing<br>
[7] Ibid., definition of syndrome extraction in quantum error correction.<br>
[8] https://en.wikipedia.org/wiki/Superconductivity<br>
[9] Google Gemini answer to "What is the connection between the MWPM algorithm and the surface code?"<br>
